use std::collections::VecDeque;

use serde::{Deserialize, Serialize};

use crate::tui::PlotSettings;

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct BucketedData {
    // generated by applying the extract fn on the first datapoint
    pub(crate) data_bucketed_start_id: usize,
    pub(crate) data_bucketed_last_id: usize,
    /// Used to write aggregated data to before moving to [bucketed]
    tmp_buf: Vec<(f64, f64)>,
    prev_xmin_shown: f64,
    prev_xmax_shown: f64,
    pub(crate) bucketed: VecDeque<(f64, f64)>,
}

impl BucketedData {
    pub fn clear(&mut self) {
        self.data_bucketed_start_id = 0;
        self.data_bucketed_last_id = 0;
        self.tmp_buf.clear();
        self.prev_xmin_shown = 0.0;
        self.prev_xmax_shown = 0.0;
        self.bucketed.clear()
    }

    pub fn maybe_rebucket<'a, T: 'a, E, A, D>(
        &mut self,
        data: D,
        plotsettings: &PlotSettings,
        extract_fn: E,
        aggregate_fn: A,
    ) where
        E: Fn(&T) -> Option<(f64, f64)>,
        A: Fn(&[(f64, f64)]) -> f64,
        D: Iterator<Item = &'a T>
            + DoubleEndedIterator<Item = &'a T>
            + ExactSizeIterator<Item = &'a T>
            + Clone,
    {
        let (xmin_shown, xmax_shown, x_interval_shown) = plotsettings.time_range();
        if data.len() == 0 {
            while self.bucketed.front().is_some_and(|(x, _)| *x < xmin_shown) {
                self.bucketed.pop_front();
            }
            while self.bucketed.back().is_some_and(|(x, _)| *x > xmax_shown) {
                self.bucketed.pop_back();
            }
            return;
        }
        let xmin_data = data.clone().find_map(&extract_fn).unwrap_or_default().0;
        let xmax_data = data.clone().rev().find_map(&extract_fn).unwrap_or_default().0;

        if x_interval_shown < 0.0 {
            return;
        }

        let panning = self.range() == (xmax_shown - xmin_shown) && !self.bucketed.is_empty();

        if xmin_shown == self.xmin() && xmax_shown == self.xmax() && panning {
            return;
        }
        if xmin_data > xmax_shown || xmax_data < xmin_shown {
            self.prev_xmin_shown = xmin_shown;
            self.prev_xmax_shown = xmax_shown;
            return;
        }

        if panning {
            if self.xmin() < xmin_shown {
                self.data_bucketed_start_id = data
                    .clone()
                    .position(|data| extract_fn(data).is_some_and(|d| d.0 >= xmin_shown))
                    .unwrap_or_default();
                // panning right, i.e. clearing data from the left of the screen
                while self.bucketed.front().is_some_and(|(x, _)| *x < xmin_shown) {
                    self.bucketed.pop_front();
                }

                let mut cur_x = self.xmax();
                loop {
                    self.tmp_buf.clear();
                    for data in data
                        .clone()
                        .skip(self.data_bucketed_last_id + 1)
                        .map(&extract_fn)
                        .take_while(|d| {
                            let o = d.is_none_or(|(x, _)| x < cur_x + x_interval_shown);
                            if o {
                                self.data_bucketed_last_id += 1;
                            }
                            o
                        })
                        .flatten()
                    {
                        self.tmp_buf.push(data)
                    }
                    if !self.tmp_buf.is_empty() {
                        self.bucketed.push_back((cur_x, aggregate_fn(&self.tmp_buf)));
                    }
                    cur_x += x_interval_shown;
                    if cur_x > xmax_shown {
                        break;
                    }
                }
            } else {
                self.data_bucketed_last_id = data
                    .clone()
                    .rposition(|data| extract_fn(data).is_some_and(|d| d.0 <= xmax_shown))
                    .unwrap_or_default();
                // panning left, i.e. clearing data from the right of the screen
                while self.bucketed.back().is_some_and(|(x, _)| *x > xmax_shown) {
                    self.bucketed.pop_back();
                }
                self.data_bucketed_start_id =
                    self.data_bucketed_start_id.min(self.data_bucketed_last_id);

                let mut cur_x = self.xmin();
                loop {
                    self.tmp_buf.clear();
                    for data in data
                        .clone()
                        .rev()
                        .skip(data.len() - self.data_bucketed_start_id)
                        .map(&extract_fn)
                        .take_while(|d| {
                            let o = d.is_none_or(|(x, _)| x >= cur_x - x_interval_shown);
                            if o {
                                self.data_bucketed_start_id -= 1;
                            }
                            o
                        })
                        .flatten()
                    {
                        self.tmp_buf.push(data)
                    }
                    if !self.tmp_buf.is_empty() {
                        self.bucketed.push_front((cur_x, aggregate_fn(&self.tmp_buf)));
                    }
                    cur_x -= x_interval_shown;
                    if cur_x < xmin_shown {
                        break;
                    }
                }
            }
        } else {
            let mut cur_x = xmin_shown;
            self.data_bucketed_start_id = data
                .clone()
                .position(|data| extract_fn(data).is_some_and(|d| d.0 >= xmin_shown))
                .unwrap_or_default();
            self.data_bucketed_last_id = self.data_bucketed_start_id;
            self.bucketed.clear();
            for _ in 0..=plotsettings.n_intervals() {
                self.tmp_buf.clear();
                for data in data
                    .clone()
                    .skip(self.data_bucketed_last_id)
                    .map(&extract_fn)
                    .take_while(|d| {
                        let o = d.is_none_or(|(x, _)| x < cur_x + x_interval_shown);
                        if o {
                            self.data_bucketed_last_id += 1;
                        }
                        o
                    })
                    .flatten()
                {
                    self.tmp_buf.push(data)
                }
                if !self.tmp_buf.is_empty() {
                    self.bucketed.push_back((cur_x, aggregate_fn(&self.tmp_buf)));
                }
                cur_x += x_interval_shown;
            }
        }
        self.prev_xmin_shown = xmin_shown;
        self.prev_xmax_shown = xmax_shown;
        self.bucketed.make_contiguous();
    }

    pub fn xmin(&self) -> f64 {
        self.prev_xmin_shown
    }

    pub fn xmax(&self) -> f64 {
        self.prev_xmax_shown
    }

    pub fn range(&self) -> f64 {
        self.xmax() - self.xmin()
    }
}
